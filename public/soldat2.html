<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soldat</title>

    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>

</head>

<body>


    <button id="enemyshootbutton">Enemyshoot</button>



    <script>
        let ile = 0;
        let cursors;
        let player;
        let bullets;
        let enemies;
        let enemybullets;

        let gunready = true;

        var enemyEvents = [];

        let platforms;
        let config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 1000 },
                    debug: false

                }
            },
            scene: {
                create: create,
                preload: preload,
                update: update
            }
        }


        let game = new Phaser.Game(config);


        function preload() {
            this.load.image('sky', 'assets/sky.png');
            this.load.image('bullet', 'assets/bullet.png');
            this.load.image('platform', 'assets/platform.png');


            this.load.spritesheet('dude', 'assets/dude.png', { frameWidth: 32, frameHeight: 48 });

        }


        function create() {
            let self = this;
            this.add.image(400, 300, 'sky');
            platforms = this.physics.add.staticGroup();
            platforms.create(300, 300, 'platform');


            bullets = this.physics.add.group();
            enemybullets = this.physics.add.group();
            enemies = this.physics.add.group();




            createAnimations(this);

            player = this.physics.add.sprite(100, 100, 'dude');
            player.setCollideWorldBounds(true);
            player.life = 100;

    

    
      

            this.physics.add.collider(player, platforms);
            this.physics.add.collider(enemies, platforms);
             this.physics.world.setBounds(0, 0, 800, 600);

                


            cursors = this.input.keyboard.createCursorKeys();


            // this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);

            // this.keySpace.on('down', function () {
            //     shoot(this);
            // }, this);

            //  this.keySpace = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
            this.input.keyboard.addListener('keydown_SPACE', function (event) {
                shoot(this);
            }, this);

            this.input.keyboard.addListener('keydown_E', function (event) {
            }, this);

            // var timedEvent = this.time.addEvent({
            //     delay: 900,
            //     callback: enemyShoot,
            //     callbackScope: this,
            //     loop: true
            // });

  

                 let collider1 = this.physics.add.collider(bullets, enemies, attack, null, this);
            let collider2 = this.physics.add.collider(enemybullets, player, enemyattack, null, this);
            collider1.bounce = 0;


        
            addEnemy();
            // addEventers();
            this.time.addEvent({
                delay:8000,
                loop:true,
                callback:function(){
                    addEnemy(self);
                    // addEventers();
                }
            })


            //addEnemy(self);

            function addEventers(){

                enemies.getChildren().forEach(function (enemy) {
                    self.time.addEvent({
                        delay: 2300,
                        loop: true,
                        callback: function () { // use a closure to capture the current enemy object
                            enemy.setVelocityY(-300);
                     
                        }, // pass the current enemy object as a parameter to the closure
                        callbackScope: self
                    });

                      self.time.addEvent({
                        delay: 2000,
                        loop: true,
                        callback: function () { // use a closure to capture the current enemy object

                            enemyShoot(enemy);
                        }, // pass the current enemy object as a parameter to the closure
                        callbackScope: self
                    });
                });

            }

       

            // function enemyJump(enemy) {
            //     enemy.setVelocityY(-300);
            // }


            function addEnemy() {
                // Create the enemy
                let enemy = enemies.create(Math.random() * 500, Math.random() * 100, 'dude');
                // Set its properties
                enemy.setTint(0xff0000);
                enemy.setCollideWorldBounds(true);
                enemy.body.setBounce(0.2);
                enemy.life = 100;
                enemy.active = true;

                self.time.addEvent({
                    delay:1500,
                    loop:true,
                    callback:function(){
                        enemyShoot(enemy);
                    },
                    callbackScope:self
                })

                // setInterval(()=>{
                //     enemy.body.velocity.y = -1000;
                // },1000)
            }


  
  

        }


         
            

        function mydebug(){
            var children = game.scene;
            console.log(game.scene.scenes[0]);
            // children.forEach(function (child) {
            //     console.log(child);
            // });
        }




        function update() {


            var keyboard = this.input.keyboard;


            // if (this.keySpace.isDown) {
            //     console.log('fsdaddsf');
            //     shoot(this);
            // }

            if (cursors.up.isDown) {
                jump();
            } else if (cursors.left.isDown) {
                goLeft();
            } else if (cursors.right.isDown) {
                goRight()
            } else {
                stand();
            }

    
        }



        function jump() {
            player.setVelocityY(-300);
        }

        function goLeft() {
            player.setVelocityX(-300);
            player.anims.play('left', true);
        }

        function goRight() {
            player.setVelocityX(150);
            player.anims.play('right', true);
        }

        function stand() {
            player.setVelocityX(0);
            player.anims.play('turn', true);
        }




        function shoot(gameinstance) {
            if(gunready){
                gunready = false;
                console.log('fsafsfds');
                // gameinstance.physics.add.sprite(100, 100, 'bullet');

                let bullet = bullets.create(player.x, player.y, 'bullet');
                bullet.body.setAllowGravity(false);
                bullet.body.setBounce(0);
                bullet.setScale(0.15);

                if (player.body.velocity.x >= 0) {
                    bullet.setVelocityX(1000);
                } else {
                    bullet.setVelocityX(-1000);
                }

                setTimeout(()=>{
                    gunready = true;
                },500)

            }

            // gameinstance.add.image(400, 300, 'bullet');


        }

        // Define an array to store the enemy events
        
    
        function enemyShoot(enemy) {
            ile++;
            console.log(ile);
            console.log('enemyShoot');
            if(enemy.active){
                let bullet = enemybullets.create(enemy.x, enemy.y, 'bullet');
                bullet.body.setAllowGravity(false);
                bullet.body.setBounce(0);
                bullet.setScale(0.15);

                bullet.setVelocityX(-1000);
            }
        }

        function attack(bullet, enemy) {
                    enemy.body.setVelocity(0, 0);

            
            console.log(enemy);
            // console.log('attack');
            // enemy.setTint(0xffff00);
            bullet.setVelocityX(0);
            bullet.body.setVelocity(0, 0);
    
            enemy.life -= 10;

            bullet.destroy();

            if (enemy.life <= 0) {
                enemy.setVisible(false);
                enemy.x = 2000;
                enemy.y= 1000;
                enemy.active = false;
            }

        }


        function enemyattack(player, bullet) {
            console.log('enemyattack');
            player.setTint(0xffff00);
            bullet.setVelocityX(0);
            bullet.body.setVelocity(0, 0);
            player.body.setVelocity(0, 0);
            bullet.destroy();

            player.life -= 10;

            if (player.life <= 0) {
                player.setVisible(false);
                player.x = 1000;
                player.y = 1000;
            }

        }

        function enemyJump(){
            if(enemy.active){
                enemy.setVelocityY(-300);
            }
        }


        function createAnimations(gameinstance) {
            gameinstance.anims.create({
                key: 'turn',
                frames: [{ key: 'dude', frame: 4 }],
                frameRate: 20
            });

            gameinstance.anims.create({
                key: 'right',
                frames: gameinstance.anims.generateFrameNumbers('dude', { start: 5, end: 8 }),
                frameRate: 10,
                repeat: -1
            });

            gameinstance.anims.create({
                key: 'left',
                frames: gameinstance.anims.generateFrameNumbers('dude', { start: 0, end: 3 }),
                frameRate: 10,
                repeat: -1
            });

        }

            function updateCounter(){
                console.log('counter');
            }





    </script>

</body>

</html>