<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auta</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>

</head>

<body>

    <script>
        let config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            },
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        }

        let auto;
        let yspeed = 0;
        let xspeed = 0;
        let speed = 0;

        let acceleration = 2;

        let cursors;

        let platforms;

        let roads;

        let speedfactor = 0;

        let road;




        new Phaser.Game(config);


        function preload() {
            this.load.image('grass', './assets/grass.png');
            this.load.image('auto', './assets/auto.png');
            this.load.image('road', './assets/road.png');
            this.load.image('platform', './assets/platform.png');
            this.load.image('platform2', './assets/platform2.png');

            this.load.image('road', './assets/road.png');
            this.load.image('road2', './assets/road2.png');




        }

        function create() {
            // this.physics.world.createDebugGraphic();
            this.add.tileSprite(0, 0, 5000, 5000, 'grass').setOrigin(0, 0);


            createBounds(this);

            createRoads(this);







            this.speedtext = this.add.text(50, 50, 'SPPED');
            auto = this.physics.add.sprite(200, 200, 'auto').setScale(0.3, 0.3);
            auto.setCollideWorldBounds(true);
            cursors = this.input.keyboard.createCursorKeys();
            auto.setBounce(0.3);
            this.physics.add.collider(platforms, auto, () => {
                if (speed > 0) {
                    speed = speed - 10;
                }

                if (speed < 0) {
                    // speed = speed + 10;
                }
                // auto.setVelocityX(auto.body.velocity.x);
                // auto.setVelocityY(200);

            });



            this.physics.world.setBounds(0, 0, 2000, 2000);

            this.cameras.main.setBounds(0, 0, 2000, 2000);
            this.cameras.main.startFollow(auto);

            this.uilayer = this.add.container(0, 0);
            this.uilayer.setScrollFactor(0, 0);
            this.uilayer.add(this.speedtext);







        }

        function createBounds(scene) {

            platforms = scene.physics.add.staticGroup();
            platforms.create(20, 10, 'platform').setScale(20, 1).refreshBody();
            platforms.create(20, 1980, 'platform').setScale(20, 1).refreshBody();

            platforms.create(20, 0, 'platform2').setScale(1, 20).refreshBody();
            platforms.create(1980, 0, 'platform2').setScale(1, 20).refreshBody();







        }

        function createRoads(scene) {
            roads = scene.physics.add.staticGroup();
            roads.create('900', '100', 'road').setScale(3, 2).refreshBody();

            roads.create('900', '100', 'road2').setScale(2, 3).refreshBody();

        }


        function updateHitboxBasedOnRotation(sprite) {
            const angle = Phaser.Math.RadToDeg(sprite.rotation); // Kąt w stopniach
            const absAngle = Math.abs(angle % 180); // Ustal "efektywny" kąt

            if (absAngle < 45 || absAngle > 135) {
                // Ustaw hitbox w orientacji poziomej
                sprite.body.setSize(120, 300); // Szeroki i niski hitbox
                // sprite.body.setOffset(-50, -25); // Przesunięcie względem środka
            } else {
                // Ustaw hitbox w orientacji pionowej
                sprite.body.setSize(300, 120); // Wąski i wysoki hitbox
                sprite.body.setOffset(-70, 100); // Przesunięcie względem środka
            }
        }

        function update() {

            let factor = 0.02 * speed / 150;

            speedfactor = 4 - speed / 100;

            if (this.physics.overlap(auto, roads)) {
                speedfactor = 10 - speed / 100;
                console.log('WIDIZ')
                if (speed > 0) {
                    speed -= 1;
                }
            } else {
                if (speed > 0) {
                    speed -= 2;
                }

                if (speed > 100) {
                    speed -= 4;
                }
            }

            if (speedfactor < 3 || speed < 0) {
                speedfactor = 3;
            }

            if (speed > 50) {
                // speedfactor = 3;
            }






            if (factor > 0.03) {
                factor = 0.03;
            }

            let rotationspeed = speed / 100;
            if (rotationspeed > 100) {
                rotationspeed = 100;
            }


            auto.setVelocityY(speed * Math.cos(auto.rotation) * -1);
            auto.setVelocityX(speed * Math.sin(auto.rotation));

            if (auto.body.touching.up) {
                // auto.setVelocityY(2000);

            }


            if (cursors.up.isDown) {
                // yspeed -= 2;
                //  auto.setVelocityY(auto.body.velocity.y - acceleration);

                speed += speedfactor;
            }

            if (cursors.down.isDown) {
                if (speed > 0) {
                    speed -= 10;
                } else {
                    speed -= speedfactor;
                }
                factor += 0.01 * speed / 200;
            }


            if (cursors.right.isDown) {
                auto.rotation += factor;
            }


            if (cursors.left.isDown) {
                auto.rotation -= factor;
            }

            if (speed > 0) {

            }

            this.speedtext.setText('Speed:' + Math.ceil(speed / 5))



            updateHitboxBasedOnRotation(auto);

            roads.getChildren().forEach((road) => {
                if (checkFullOverlap(auto, road)) {
                    auto.setTint(0x00ff00);
                    if (speed > 0) {
                        // speed -= 1;
                    }
                } else {
                    auto.setTint(0xffffff);

                    if (speed > 100) {
                        speed -= 4;
                    }

                }
            })






        }

        function checkFullOverlap(obj1, obj2) {
            // Pobierz prostokątne granice obu obiektów

            if (obj1.y > obj2.y) {
                return true;
            }

            return false
        }



    </script>

</body>

</html>